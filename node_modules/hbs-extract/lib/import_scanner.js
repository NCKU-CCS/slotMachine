(function() {

/* ref: https://github.com/wycats/handlebars.js/blob/master/docs/compiler-api.md
 *
 * */

var Handlebars = require('handlebars');
var _ = require('lodash');

function ImportScanner(afterKeyCreate) {
  this.data = {};
  this.blocks = [];
  this.afterKeyCreate = afterKeyCreate || function(path){};
}

var Visitor = Handlebars.Visitor;
ImportScanner.prototype = new Visitor();

/* function for override
 * will traverse data json, and be called when key is being created
 * path: array of keys
 * */
  // do what you want

ImportScanner.prototype.MustacheStatement = function(mustache) {
  var parts = mustache.path.parts;
  while (this.blocks.length > 0 && !isInBlocks(mustache, this.blocks)) {
    this.blocks.pop(); 
  }

  this._deepInsert(this.blocks, this.data, parts);
  Visitor.prototype.MustacheStatement.call(this, mustache);
};

ImportScanner.prototype.BlockStatement = function(block) {
  var mustache = block.params[0];
  while (this.blocks.length > 0 && !isInBlocks(mustache, this.blocks)) {
    this.blocks.pop(); 
  }

  if (block.path.original === 'each') {
    this._deepInsert(this.blocks, this.data, block.params[0].parts, [{}]);
    this.blocks.push(block);
  }
 
  Visitor.prototype.BlockStatement.call(this, block);
};

ImportScanner.prototype._deepInsert = function(blocks, key, parts, value) {
  var path = [];
  // go to current block (array)
  blocks.forEach(function(block) {
    // object key
    block.params[0].parts.forEach(function(node) {
      key = key[node];
      path.push(node);
    });
    key = key[0];
  });

  // init key value
  for (var i = 0; i < parts.length; ++ i) {
    updateData.call(key, parts[i]);
    path.push(parts[i]);
    this.afterKeyCreate(path);
    if (i < (parts.length-1)){
      updateData.call(key, parts[i], parts[i+1]);
      key = key[parts[i]];
    }
    else if (parts[i+1]) {
      path.push(parts[i+1]);
      this.afterKeyCreate(path);
    }
  }

   // init block array
  if (value && _.isArray(value)) {
    key[parts[parts.length-1]] = undefined;
    updateData.call(key, parts[parts.length-1], value);
  }
};

function isInBlocks(mustache, blocks) {
  var innerBlock = blocks[blocks.length-1];
  return (mustache.loc.end.line < innerBlock.loc.end.line);
}

function updateData(key, value) {
  if (this[key] === undefined) {
    this[key] = value || '';
  }
  else if (value){
    this[key] = this[key] === '' ? {} : this[key];
    this[key][value] = '';
  }
}

module.exports = ImportScanner;

})();
